--[[
    Looting Takes Time - Improved
    Original by: xcvb
    Improvements by: Abraham
    
    Features:
    1. Items hidden until searched - no flash on open
    2. Grid position preservation - items don't shuffle
    3. Rank-based search time - higher rank = longer search
    4. Two reveal modes: positional (L-R, T-B) or size-based
    5. Dark silhouette placeholder mode
    6. Animated "Searching..." indicator
--]]

------------------------------------------------------------------------
-- STATE TABLES
------------------------------------------------------------------------
local corpses = {}              -- [npc_id][item_id] = nil/true/false
local initial_inv = {}          -- [npc_id][item_id] = true
local corpse_rank = {}          -- [npc_id] = rank_multiplier
local item_positions = {}       -- [npc_id][item_id] = {row, col, w, h}
local item_reveal_order = {}    -- [npc_id] = {item_id, ...}
local loading_spinners = {}     -- [item_id] = CUIStatic element
local spinner_xml = nil         -- Cached XML for spinners
local resumed_search = {}       -- [npc_id] = true if search was resumed this session
local cur_npc_id = nil

-- Cached values for performance
local cached_aspect_correction = nil  -- Calculated once per session
local cached_sil_r, cached_sil_g, cached_sil_b = nil, nil, nil  -- Recalculated on settings change
local cached_looting_text = nil       -- Cached looting text per faction
local cached_looting_faction = nil    -- Track faction for cache invalidation

-- Get cached aspect ratio correction (STALKER UI is 4:3, widescreen stretches width)
local function get_aspect_correction()
    if not cached_aspect_correction then
        local screen_w = device().width
        local screen_h = device().height
        cached_aspect_correction = (screen_h / screen_w) * (4 / 3)
    end
    return cached_aspect_correction
end

------------------------------------------------------------------------
-- HARUKA'S SKILLS INTEGRATION
------------------------------------------------------------------------
-- Returns time multiplier based on scavenging skill (1.0 = no bonus, 0.5 = max bonus)
-- Automatically detects if Haruka's Skills mod is installed
-- Also returns debug info: detected, current_level, max_level
local function get_haruka_scavenging_multiplier()
    -- Check if Haruka's Skills mod is installed
    if not haru_skills then 
        return 1.0, false, 0, 0
    end
    
    -- Check if skills_levels table exists
    if not haru_skills.skills_levels then 
        return 1.0, false, 0, 0
    end
    
    -- Check if scavenging skill exists
    local scav = haru_skills.skills_levels["scavenging"]
    if not scav then 
        return 1.0, true, 0, 0  -- Mod detected but scavenging skill not found
    end
    
    -- Get current and max level with safe defaults
    local current_level = scav.current_level or 0
    local max_level = scav.max_level or 15
    
    -- Prevent division by zero
    if max_level <= 0 then
        return 1.0, true, current_level, max_level
    end
    
    -- Calculate multiplier: 1.0 at level 0, 0.5 at max level
    -- Formula: mult = 1.0 - (progress * 0.5)
    local progress = math.min(current_level / max_level, 1.0)  -- Clamp to 1.0 max
    local multiplier = 1.0 - (progress * 0.5)
    
    return multiplier, true, current_level, max_level
end

local sfind = string.find

------------------------------------------------------------------------
-- SOUND TABLES
------------------------------------------------------------------------
local snd_t = {
    ["w_ammo"] = { "ammo_1", "ammo_2", "ammo_3", "ammo_4" },
    ["w_misc"] = { "parts_1", "parts_2", "parts_3" },
    ["w_explosive"] = { "grenade_1", "grenade_2" },
    ["w_melee"] = { "knife_1", "knife_2" },
    ["wpn"] = { "wpn_1", "wpn_2" },
    ["o_helmet"] = { "cloth_1" },
    ["outfit"] = { "cloth_2", "cloth_3" },
    ["i_arty"] = { "cloth_1", "cloth_2" },
    ["i_arty_cont"] = { "wpnbig_1", "wpnbig_2" },
    ["i_arty_junk"] = { "cloth_1", "cloth_2" },
    ["i_attach"] = { "parts_1", "parts_2", "parts_3" },
    ["i_drink"] = { "bottle_1", "bottle_2", "bottle_3", "bottle_4" },
    ["i_medical"] = { "pills_1", "pills_2" },
    ["i_tool"] = { "take_all" },
    ["i_device"] = { "parts_1", "parts_2" },
    ["i_letter"] = { "money_paper" },
    ["i_part"] = { "parts_1", "parts_2", "parts_3" },
    ["money_paper"] = { "money_paper" },
    ["money_coin"] = { "money_coin_1", "money_coin_2" },
    ["generic"] = { "generic_3", "generic_4", "generic_5", "parts_2" },
}

local replace_snd_by_sec = {
    ["money_paper"] = { "cash", "money" },
    ["money_coin"] = { "roubles" },
    ["generic"] = { "joint", "marijuana", "cigarettes", "cigar", "tobacco", "drug_booster", "bandage", "jgut", "stimpack", "rebirth", "tetanus", "glucose", "cocaine", "salicidic_acid", "morphine", "adrenalin" },
}

local replace_snd_by_kind = {
    ["wpn"] = { "w_rifle", "w_pistol", "w_smg", "w_shotgun", "w_sniper" },
    ["outfit"] = { "o_heavy", "o_light", "o_medium", "o_sci" },
}

------------------------------------------------------------------------
-- MCM SETTINGS
------------------------------------------------------------------------
local enable_corpses = true
local enable_containers = false
local block_mags_redux_sort = false  -- Completely block Magazines Redux sorting in NPC inventory
local time_max = 20
local first_item_delay = 1        -- Delay before anything appears
local silhouette_appear_min = 0.2 -- Min random time for silhouette appearance
local silhouette_appear_max = 1.5 -- Max random time for silhouette appearance
local delay_between_min = 0.1     -- Min delay from silhouette to reveal
local delay_between_max = 1.0     -- Max delay from silhouette to reveal
local silhouette_intensity = 90   -- Darkness percentage (0-100)
local silhouette_color_r = 0      -- Base color R (0-255)
local silhouette_color_g = 0      -- Base color G (0-255)
local silhouette_color_b = 0      -- Base color B (0-255)
local spinner_size = 32           -- Spinner size in pixels
local spinner_scale_mode = 1      -- 1=fixed, 2=scale with item
local spinner_style = "half_circle_colored"  -- Icon style folder name
local spinner_opacity = 100       -- Spinner opacity (10-100%)

-- Table of spinner styles that have valid textures
-- Runtime validation will add more styles if their textures exist
local validated_spinner_styles = {
    ["default"] = true,
    ["arrows"] = true,
    ["wheel"] = true,
    ["chasing_arrows"] = true,
    ["fading_line"] = true,
    ["growing_ring"] = true,
    ["half_circle"] = true,
    ["half_circle_colored"] = true,
    ["half_circle_dimmed"] = true,
    ["half_circle_green"] = true,
    ["line"] = true,
    ["recycle"] = true,
    ["search"] = true,
    ["search_orange"] = true,
    ["spinning_segments"] = true,
    ["two_arrows"] = true,
}

local hud_enable = true
local hud_icon = 1
local hud_indicator_style = "default"  -- style folder for animated indicator
local hud_indicator_x = 165
local hud_indicator_y = 80
local hud_indicator_scale = 70  -- scale percentage
local hud_text_x = 210
local hud_text_y = 82
local sound_enable = true
local sound_enable_vol = 1
local sound_bg_enable = true
local sound_bg_enable_vol = 1.25
local rank_enable = true
local reveal_mode = 1           -- 1=positional, 2=size-based
local placeholder_mode = 1      -- 0=none, 1=dark silhouettes, 2=loading icon
local debugx = false

local rank_mult = {
    ["novice"] = 0.5,
    ["trainee"] = 0.5,
    ["experienced"] = 0.8,
    ["professional"] = 0.8,
    ["veteran"] = 1.2,
    ["expert"] = 1.2,
    ["master"] = 1.3,
    ["legend"] = 1.7,
}

------------------------------------------------------------------------
-- DEBUG (defined early so load_settings can use it)
------------------------------------------------------------------------
local function pr(fmt, ...)
    if not debugx then return end
    local args = {...}
    local msg
    if #args > 0 then
        msg = string.format(fmt, ...)
    else
        msg = fmt
    end
    printf("[LootTime] %s", msg)
end

local function load_settings()
    local mcm = loot_searching_mcm
    
    local function get_num(key, default)
        local val = mcm.get_config(key)
        if val == nil then return default end
        return tonumber(val) or default
    end
    
    local function get_bool(key, default)
        local val = mcm.get_config(key)
        if val == nil then return default end
        return val
    end
    
    -- Targets
    enable_corpses = get_bool("enable_corpses", true)
    enable_containers = get_bool("enable_containers", false)
    
    -- Compatibility
    block_mags_redux_sort = get_bool("block_mags_redux_sort", false)
    
    -- Timing
    time_max = get_num("time_max", 20)
    first_item_delay = get_num("first_item_delay", 1)
    silhouette_appear_min = get_num("silhouette_appear_min", 0.2)
    silhouette_appear_max = get_num("silhouette_appear_max", 1.5)
    delay_between_min = get_num("delay_between_min", 0.1)
    delay_between_max = get_num("delay_between_max", 1.0)
    
    -- Silhouette settings
    silhouette_intensity = get_num("silhouette_intensity", 90)
    silhouette_color_r = get_num("silhouette_color_r", 0)
    silhouette_color_g = get_num("silhouette_color_g", 0)
    silhouette_color_b = get_num("silhouette_color_b", 0)
    spinner_size = get_num("spinner_size", 32)
    spinner_scale_mode = get_num("spinner_scale_mode", 1)
    spinner_style = mcm.get_config("spinner_style") or "default"
    spinner_opacity = get_num("spinner_opacity", 100)
    
    -- Dynamically validate spinner style by checking if texture exists
    if not validated_spinner_styles[spinner_style] then
        local fs = getFS()
        local texture_path = "textures\\ui\\loot_searching\\" .. spinner_style .. "\\icon_looting_01b.dds"
        if fs:exist("$game_data$", texture_path) then
            validated_spinner_styles[spinner_style] = true
            pr("~ Validated spinner style: %s", spinner_style)
        else
            pr("! Spinner style '%s' has no textures, will use default", spinner_style)
        end
    end
    
    hud_enable = get_bool("hud_enable", true)
    hud_icon = get_num("hud_icon", 1)
    hud_indicator_style = mcm.get_config("hud_indicator_style") or "default"
    hud_indicator_x = get_num("hud_indicator_x", 165)
    hud_indicator_y = get_num("hud_indicator_y", 80)
    hud_indicator_scale = get_num("hud_indicator_scale", 70)
    hud_text_x = get_num("hud_text_x", 210)
    hud_text_y = get_num("hud_text_y", 82)
    sound_enable = get_bool("sound_enable", true)
    sound_enable_vol = get_num("sound_enable_vol", 1)
    sound_bg_enable = get_bool("sound_bg_enable", true)
    sound_bg_enable_vol = get_num("sound_bg_enable_vol", 1.25)
    rank_enable = get_bool("rank_enable", true)
    reveal_mode = get_num("reveal_mode", 1)
    placeholder_mode = get_num("placeholder_mode", 1)
    debugx = get_bool("debugx", false)
    
    rank_mult["novice"] = get_num("rank_novice", 0.5)
    rank_mult["trainee"] = get_num("rank_novice", 0.5)
    rank_mult["experienced"] = get_num("rank_experienced", 0.8)
    rank_mult["professional"] = get_num("rank_experienced", 0.8)
    rank_mult["veteran"] = get_num("rank_veteran", 1.2)
    rank_mult["expert"] = get_num("rank_veteran", 1.2)
    rank_mult["master"] = get_num("rank_master", 1.3)
    rank_mult["legend"] = get_num("rank_legend", 1.7)
end

------------------------------------------------------------------------
-- UTILITY
------------------------------------------------------------------------
local function is_valid_target(npc)
    if not npc then return false end
    
    -- Check if it's a container (invbox/stash)
    if IsInvbox(npc) then
        return enable_containers
    end
    
    -- Check if it's a corpse
    if IsStalker(npc) and not npc:alive() then
        return enable_corpses
    end
    
    return false
end

local function get_rank_multiplier(npc)
    if not rank_enable then return 1.0 end
    if not npc then return 1.0 end
    
    local rank_name = nil
    if ranks and ranks.get_obj_rank_name then
        rank_name = ranks.get_obj_rank_name(npc)
    end
    
    if not rank_name or rank_name == "" then
        local rank_val = npc.character_rank and npc:character_rank() or 0
        if rank_val < 300 then rank_name = "novice"
        elseif rank_val < 600 then rank_name = "experienced"
        elseif rank_val < 900 then rank_name = "veteran"
        elseif rank_val < 1200 then rank_name = "master"
        else rank_name = "legend"
        end
    end
    
    return rank_mult[rank_name] or 1.0
end

-- Check if item is hidden (blocks interaction) - true for both "hidden" and "silhouette" states
function is_item_hidden(npc_id, item_id)
    if not npc_id or not item_id then return false end
    if not corpses[npc_id] then return false end
    local state = corpses[npc_id][item_id]
    return state == "hidden" or state == "silhouette"
end

------------------------------------------------------------------------
-- SOUND
------------------------------------------------------------------------
local function play_found_sound(item_id)
    if not sound_enable then return end
    
    -- Try to get item object - first from level, then try inventory
    local obj = level.object_by_id(item_id)
    if not obj then
        -- Item might be in inventory, not on level - try to get it from actor or NPC
        obj = db.actor:object(item_id)
    end
    
    -- If still not found, try active NPC (loot target)
    if not obj then
        local gui = ui_inventory.GUI
        if gui and gui.npc then
            obj = gui.npc:object(item_id)
        end
    end
    
    local sec
    if obj then
        sec = obj:section()
    else
        -- Fallback: play generic sound if we can't determine item type
        pr("! Could not find item %d for sound, using generic", item_id)
        local snd_list = snd_t["generic"]
        local snd_name = snd_list[math.random(#snd_list)]
        local snd_path = "interface\\items\\inv_items_" .. snd_name
        local snd = sound_object(snd_path)
        if snd then
            snd:play_at_pos(db.actor, VEC_ZERO, 0, sound_object.s2d)
            snd.volume = snd.volume * sound_enable_vol
        end
        return
    end
    
    local kind = SYS_GetParam(0, sec, "kind", "generic")
    
    local skip_sfind = false
    for new_kind, kinds in pairs(replace_snd_by_kind) do
        for _, k in ipairs(kinds) do
            if k == kind then
                kind = new_kind
                skip_sfind = true
                break
            end
        end
        if skip_sfind then break end
    end
    
    if not skip_sfind then
        for new_kind, patterns in pairs(replace_snd_by_sec) do
            for _, pat in ipairs(patterns) do
                if sfind(sec, pat) then
                    kind = new_kind
                    break
                end
            end
        end
    end
    
    local snd_list = snd_t[kind] or snd_t["generic"]
    local snd_name = snd_list[math.random(#snd_list)]
    local snd_path = "interface\\items\\inv_items_" .. snd_name
    
    local snd = sound_object(snd_path)
    if snd then
        snd:play_at_pos(db.actor, VEC_ZERO, 0, sound_object.s2d)
        snd.volume = snd.volume * sound_enable_vol
    end
end

------------------------------------------------------------------------
-- GRID POSITION CALCULATION
------------------------------------------------------------------------
local sort_cache = { w = {}, h = {}, k = {} }
local item_order = nil

local function init_item_order()
    if item_order then return end
    item_order = {}
    local n = ini_sys:line_count("item_kind_order")
    for i = 0, n - 1 do
        local _, kind, order = ini_sys:r_line_ex("item_kind_order", i, "", "")
        if kind and order then
            item_order[kind] = tonumber(order) or 30
        end
    end
    item_order["na"] = size_table(item_order) + 1
end

local function get_sort_info(sec)
    if not sort_cache.w[sec] then
        sort_cache.w[sec] = SYS_GetParam(2, sec, "inv_grid_width", 1)
        sort_cache.h[sec] = SYS_GetParam(2, sec, "inv_grid_height", 1)
        local kind = SYS_GetParam(0, sec, "kind", "na")
        if not item_order or not item_order[kind] then kind = "na" end
        sort_cache.k[sec] = item_order and item_order[kind] or 30
    end
    return sort_cache.w[sec], sort_cache.h[sec], sort_cache.k[sec]
end

local function sort_items_by_size(items)
    init_item_order()
    
    -- Check if Magazines Redux is installed for magazine prioritization
    local is_magazine = magazine_binder and magazine_binder.is_magazine
    local is_carried_mag = magazine_binder and magazine_binder.is_carried_mag
    
    table.sort(items, function(a, b)
        -- If Magazines Redux is installed, prioritize magazines
        if is_magazine then
            local a_carried = is_carried_mag and is_carried_mag(a.id)
            local b_carried = is_carried_mag and is_carried_mag(b.id)
            local a_mag = is_magazine(a.id)
            local b_mag = is_magazine(b.id)
            
            -- Carried/ready mags first
            if a_carried ~= b_carried then
                return a_carried
            end
            -- Regular magazines second
            if a_mag ~= b_mag then
                return a_mag
            end
        end
        
        -- Standard sorting: by size, kind, section, id
        local aw, ah, ak = get_sort_info(a.sec)
        local bw, bh, bk = get_sort_info(b.sec)
        if aw ~= bw then return aw > bw end
        if ah ~= bh then return ah > bh end
        if ak ~= bk then return ak < bk end
        if a.sec ~= b.sec then return a.sec < b.sec end
        return a.id < b.id
    end)
    return items
end

local function calculate_positions(npc_id, npc)
    item_positions[npc_id] = {}
    
    local items = {}
    local function collect(_, obj)
        local sec = obj:section()
        local w, h = get_sort_info(sec)
        local weight = SYS_GetParam(2, sec, "inv_weight", 1)
        table.insert(items, { 
            id = obj:id(), 
            sec = sec,
            w = w,
            h = h,
            weight = weight,
            grid_size = w * h
        })
    end
    npc:iterate_inventory(collect, npc)
    
    sort_items_by_size(items)
    
    local cols = 10
    local gui = ui_inventory.GUI
    if gui and gui.CC and gui.CC["npc_bag"] and gui.CC["npc_bag"].cols then
        cols = gui.CC["npc_bag"].cols
    end
    
    local grid = {}
    for r = 1, 100 do
        grid[r] = {}
        for c = 1, cols do
            grid[r][c] = true
        end
    end
    
    local function is_free(row, col, w, h)
        if col + w - 1 > cols then return false end
        for r = row, row + h - 1 do
            if not grid[r] then return false end
            for c = col, col + w - 1 do
                if not grid[r][c] then return false end
            end
        end
        return true
    end
    
    local function take(row, col, w, h)
        for r = row, row + h - 1 do
            for c = col, col + w - 1 do
                grid[r][c] = false
            end
        end
    end
    
    local function find_free(w, h)
        for row = 1, 100 do
            for col = 1, cols - w + 1 do
                if is_free(row, col, w, h) then
                    return row, col
                end
            end
        end
        return 1, 1
    end
    
    for _, item in ipairs(items) do
        local row, col = find_free(item.w, item.h)
        take(row, col, item.w, item.h)
        item.row = row
        item.col = col
        item_positions[npc_id][item.id] = { row = row, col = col, w = item.w, h = item.h }
    end
    
    item_reveal_order[npc_id] = {}
    
    if reveal_mode == 1 then
        table.sort(items, function(a, b)
            if a.row ~= b.row then return a.row < b.row end
            return a.col < b.col
        end)
        pr("  Reveal mode: POSITIONAL")
    else
        -- Size-based: larger/heavier items first
        table.sort(items, function(a, b)
            local score_a = a.weight + a.grid_size
            local score_b = b.weight + b.grid_size
            return score_a > score_b  -- Larger first
        end)
        pr("  Reveal mode: SIZE-BASED (larger first)")
    end
    
    for i, item in ipairs(items) do
        item_reveal_order[npc_id][i] = item.id
    end
    
    pr("Calculated %d positions", #items)
end

------------------------------------------------------------------------
-- LOADING SPINNER MANAGEMENT
------------------------------------------------------------------------
local function get_spinner_xml()
    if not spinner_xml then
        spinner_xml = CScriptXmlInit()
        spinner_xml:ParseFile("ui_xcvb_looting.xml")
    end
    return spinner_xml
end

local function create_spinner_for_cell(item_id, cell_item)
    if loading_spinners[item_id] then return end
    if not cell_item then return end
    
    local ico = cell_item.ico
    if not ico then return end
    
    local xml = get_spinner_xml()
    if not xml then return end
    
    -- Create spinner as child of the icon
    local spinner = xml:InitStatic("cell_spinner", ico)
    if not spinner then
        pr("! Failed to create spinner for item %d", item_id)
        return
    end
    
    -- Set texture based on selected style, with fallback to default
    -- Use validated_spinner_styles table to check if style has textures
    local style_to_use = spinner_style
    if not validated_spinner_styles[style_to_use] then
        pr("! Style '%s' not validated, falling back to default", spinner_style)
        style_to_use = "default"
    end
    
    local texture_path = "ui\\loot_searching\\" .. style_to_use .. "\\icon_looting_01b"
    spinner:InitTexture(texture_path)
    
    -- Get icon dimensions
    local ico_w = ico:GetWidth()
    local ico_h = ico:GetHeight()
    
    -- Calculate spinner size based on mode
    local sz
    if spinner_scale_mode == 2 then
        -- Scale with item: 50% of smallest dimension, capped by spinner_size
        sz = math.min(ico_w, ico_h) * 0.5
        sz = math.max(sz, 16)  -- Minimum 16px
        sz = math.min(sz, spinner_size)  -- Maximum from settings
    else
        -- Fixed size from settings
        sz = spinner_size
    end
    
    -- Apply cached aspect ratio correction to keep spinner square
    local aspect_correction = get_aspect_correction()
    local corrected_w = sz * aspect_correction
    
    spinner:SetWndSize(vector2():set(corrected_w, sz))
    
    -- Center spinner on the icon (using corrected width)
    local x = (ico_w - corrected_w) / 2
    local y = (ico_h - sz) / 2
    spinner:SetWndPos(vector2():set(x, y))
    
    spinner:SetStretchTexture(true)
    
    -- Apply opacity
    local alpha = math.floor(spinner_opacity * 255 / 100)
    spinner:SetTextureColor(GetARGB(alpha, 255, 255, 255))
    
    spinner:Show(true)
    
    loading_spinners[item_id] = spinner
    pr("  Created spinner for item %d at (%.0f, %.0f) size=%.0fx%.0f style=%s opacity=%d%%", item_id, x, y, corrected_w, sz, spinner_style, spinner_opacity)
end

local function remove_spinner(item_id)
    local spinner = loading_spinners[item_id]
    if spinner then
        spinner:Show(false)
        loading_spinners[item_id] = nil
        pr("  Removed spinner for item %d", item_id)
    end
end

local function cleanup_all_spinners()
    for item_id, spinner in pairs(loading_spinners) do
        if spinner then
            spinner:Show(false)
        end
    end
    loading_spinners = {}
    pr("Cleaned up all spinners")
end

------------------------------------------------------------------------
-- SEARCH TIME CALCULATION
------------------------------------------------------------------------
-- Get the appropriate looting text based on player faction
local function get_looting_text()
    -- Check if we have a cached value for the current faction
    local faction
    if db.actor then
        local se_actor = alife_object(db.actor:id())
        if se_actor then
            faction = se_actor:community()
        end
    end
    
    -- Return cached value if faction hasn't changed
    if cached_looting_text and cached_looting_faction == faction then
        return cached_looting_text
    end
    
    -- Update cache
    cached_looting_faction = faction
    if faction == "bandit" or faction == "renegade" then
        cached_looting_text = game.translate_string("st_xcvb_looting_bandit")
    else
        cached_looting_text = game.translate_string("st_xcvb_looting")
    end
    return cached_looting_text
end

-- Helper function to get random delay between items
local function get_random_delay()
    return delay_between_min + math.random() * (delay_between_max - delay_between_min)
end

local function calc_search_time(order_index, npc_id, total_items)
    local rmult = corpse_rank[npc_id] or 1.0
    
    -- Calculate time: first_delay + cumulative random appear times + reveal delay
    local time = first_item_delay
    for i = 1, order_index do
        time = time + silhouette_appear_min + math.random() * (silhouette_appear_max - silhouette_appear_min)
    end
    time = time + get_random_delay()
    time = time * rmult
    
    -- Apply Haruka's Skills scavenging bonus (if mod is installed)
    -- Note: logging handled in ParseInventory to avoid duplicates
    local haruka_mult = get_haruka_scavenging_multiplier()
    time = time * haruka_mult
    
    -- Cap max time based on total items count
    local effective_max = time_max * rmult * haruka_mult
    if total_items then
        if total_items <= 2 then
            effective_max = math.min(effective_max, 3.0 * haruka_mult)
        elseif total_items <= 5 then
            effective_max = math.min(effective_max, 7.0 * haruka_mult)
        end
    end
    
    time = math.min(time, effective_max)
    return math.max(time, 0.3)
end

------------------------------------------------------------------------
-- CORPSE/CONTAINER INITIALIZATION
------------------------------------------------------------------------
-- Note: Primary initialization now happens in ParseInventory to prevent flash
-- This function is kept as a backup and to set cur_npc_id
function save_initial_inv()
    local inventory = ui_inventory.GUI
    if not inventory then return true end
    
    local npc = inventory:GetPartner()
    local npc_id = npc and npc:id()
    
    if inventory.mode ~= "loot" or not npc_id then return true end
    if not is_valid_target(npc) then return true end
    
    -- Initialization should have happened in ParseInventory already
    -- Just set cur_npc_id here
    cur_npc_id = npc_id
    return true
end

------------------------------------------------------------------------
-- ITEM REVEAL (Two-stage for loading icon mode)
------------------------------------------------------------------------

-- Stage 1: Hidden -> Silhouette (for loading icon mode)
function reveal_silhouette(npc_id, item_id)
    if not corpses[npc_id] then return true end
    if corpses[npc_id][item_id] ~= "hidden" then return true end
    
    pr(">>> Silhouette revealed for item %d", item_id)
    
    corpses[npc_id][item_id] = "silhouette"
    
    -- Refresh inventory to show the silhouette
    local gui = ui_inventory.GUI
    if gui and actor_menu.get_last_mode() == 4 then
        gui:UpdateInventories()
    end
    
    return true
end

-- Stage 2 (or single stage): Silhouette/Hidden -> Fully Revealed
function reveal_item(npc_id, item_id)
    if not corpses[npc_id] then return true end
    local state = corpses[npc_id][item_id]
    if not state then return true end  -- Already revealed
    
    pr(">>> Fully revealed item %d (was: %s)", item_id, tostring(state))
    
    play_found_sound(item_id)
    corpses[npc_id][item_id] = false
    
    -- Remove loading spinner if present
    remove_spinner(item_id)
    
    -- Check if all items are now revealed
    local all_revealed = true
    for id, st in pairs(corpses[npc_id]) do
        if st == "hidden" or st == "silhouette" then
            all_revealed = false
            break
        end
    end
    
    -- If all items revealed, clear position cache to allow normal sorting
    if all_revealed and item_positions[npc_id] then
        pr(">>> All items revealed for %d, clearing position cache (Magazines Redux can now sort freely)", npc_id)
        item_positions[npc_id] = nil
    end
    
    -- Restore cell color if in placeholder mode
    local gui = ui_inventory.GUI
    if gui and placeholder_mode > 0 then
        local cc = gui.CC and gui.CC["npc_bag"]
        if cc then
            local ci = cc:GetCell_ID(item_id)
            if ci and ci.ico then
                ci.ico:SetTextureColor(GetARGB(255, 255, 255, 255))
            end
        end
    end
    
    -- Refresh inventory
    if gui and actor_menu.get_last_mode() == 4 then
        if placeholder_mode == 0 then
            if zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.NPCINV then
                gui.CC["npc_bag"]:Reset()
            end
        end
        gui:UpdateInventories()
    end
    
    return true
end

------------------------------------------------------------------------
-- PLACEHOLDER VISUALS (Silhouettes and Loading Icons)
------------------------------------------------------------------------
local function update_silhouette_color_cache()
    -- Calculate color based on intensity and base color
    -- At 100% intensity: color is close to base color (dark)
    -- At 50% intensity: color is brighter (towards white)
    local brightness = (100 - silhouette_intensity) / 100
    local r = math.floor(silhouette_color_r + (255 - silhouette_color_r) * brightness)
    local g = math.floor(silhouette_color_g + (255 - silhouette_color_g) * brightness)
    local b = math.floor(silhouette_color_b + (255 - silhouette_color_b) * brightness)
    cached_sil_r = math.max(0, math.min(255, r))
    cached_sil_g = math.max(0, math.min(255, g))
    cached_sil_b = math.max(0, math.min(255, b))
end

local function get_silhouette_color()
    -- Return cached values (updated on settings change)
    if not cached_sil_r then
        update_silhouette_color_cache()
    end
    return cached_sil_r, cached_sil_g, cached_sil_b
end

------------------------------------------------------------------------
-- PARSEINVENTORY OVERRIDE
------------------------------------------------------------------------
local basePI = ui_inventory.UIInventory.ParseInventory

function ui_inventory.UIInventory:ParseInventory(npc, all, id_list, ignore_kind)
    local inv = basePI(self, npc, all, id_list, ignore_kind)
    
    if self.mode ~= "loot" then return inv end
    if not self:IsInvOwner(npc) then return inv end
    if not is_valid_target(npc) then return inv end
    
    local npc_id = npc:id()
    if npc_id == AC_ID then return inv end
    
    -- Initialize corpse/container immediately if not done yet (prevents flash)
    if not initial_inv[npc_id] then
        local is_container = IsInvbox(npc)
        pr("=== Immediate init %s %d (placeholder_mode=%d) ===", 
           is_container and "container" or "corpse", npc_id, placeholder_mode)
        
        initial_inv[npc_id] = {}
        corpses[npc_id] = {}
        corpse_rank[npc_id] = is_container and 1.0 or get_rank_multiplier(npc)
        
        -- Get Haruka's Skills multiplier (and log status)
        local haruka_mult, haruka_detected, haruka_level, haruka_max = get_haruka_scavenging_multiplier()
        if haruka_detected then
            pr("  Haruka's Skills: DETECTED (Scavenging level " .. haruka_level .. "/" .. haruka_max .. ", multiplier x" .. string.format("%.2f", haruka_mult) .. ")")
        else
            pr("  Haruka's Skills: NOT DETECTED")
        end
        
        calculate_positions(npc_id, npc)
        
        local function record_item(_, obj)
            initial_inv[npc_id][obj:id()] = true
        end
        npc:iterate_inventory(record_item, npc)
        
        local order = item_reveal_order[npc_id]
        
        if placeholder_mode == 2 then
            -- Loading icon mode: two-stage reveal
            local total_items = #order
            local rmult = corpse_rank[npc_id] or 1.0
            
            -- Determine effective max time based on item count (apply Haruka's Skills bonus)
            local effective_max = time_max * rmult * haruka_mult
            if total_items <= 2 then
                effective_max = math.min(effective_max, 3.0 * haruka_mult)
            elseif total_items <= 5 then
                effective_max = math.min(effective_max, 7.0 * haruka_mult)
            end
            
            -- Track cumulative silhouette time
            local cumulative_time = first_item_delay * haruka_mult
            
            for i, item_id in ipairs(order) do
                corpses[npc_id][item_id] = "hidden"
                
                -- Add random appear time for this item's silhouette (scaled by Haruka's Skills)
                local appear_time = silhouette_appear_min + math.random() * (silhouette_appear_max - silhouette_appear_min)
                appear_time = appear_time * haruka_mult
                cumulative_time = cumulative_time + appear_time
                
                -- Apply rank multiplier
                local silhouette_time = cumulative_time * rmult
                
                -- Cap silhouette time (use max delay for safety margin)
                silhouette_time = math.min(silhouette_time, effective_max - delay_between_max * haruka_mult * 0.5)
                silhouette_time = math.max(silhouette_time, 0.1)
                
                -- Reveal time is silhouette time + random delay (scaled by Haruka's Skills)
                local reveal_time = silhouette_time + get_random_delay() * haruka_mult
                reveal_time = math.min(reveal_time, effective_max)
                
                CreateTimeEvent("item_silhouette", "silhouette_" .. npc_id .. "_" .. item_id,
                                silhouette_time, reveal_silhouette, npc_id, item_id)
                CreateTimeEvent("item_hiding", "item_hiding_" .. npc_id .. "_" .. item_id,
                                reveal_time, reveal_item, npc_id, item_id)
            end
        else
            -- Normal mode: single-stage reveal
            local total_items = #order
            for i, item_id in ipairs(order) do
                corpses[npc_id][item_id] = "hidden"
                local search_time = calc_search_time(i, npc_id, total_items)
                CreateTimeEvent("item_hiding", "item_hiding_" .. npc_id .. "_" .. item_id,
                                search_time, reveal_item, npc_id, item_id)
            end
        end
        
        cur_npc_id = npc_id
    else
        -- Reopening - check if there are still hidden items that need time events
        -- Only do this once per session (ParseInventory may be called multiple times)
        if corpses[npc_id] and not resumed_search[npc_id] then
            local hidden_count = 0
            local silhouette_count = 0
            
            for item_id, state in pairs(corpses[npc_id]) do
                if state == "hidden" then
                    hidden_count = hidden_count + 1
                elseif state == "silhouette" then
                    silhouette_count = silhouette_count + 1
                end
            end
            
            if hidden_count > 0 or silhouette_count > 0 then
                pr("=== Resuming search for %d (hidden=%d, silhouette=%d) ===", 
                   npc_id, hidden_count, silhouette_count)
                
                resumed_search[npc_id] = true  -- Mark as resumed
                
                -- Get Haruka's Skills multiplier for resumed search
                local haruka_mult, haruka_detected, haruka_level, haruka_max = get_haruka_scavenging_multiplier()
                if haruka_detected then
                    pr("  Haruka's Skills: DETECTED (Scavenging level " .. haruka_level .. "/" .. haruka_max .. ", multiplier x" .. string.format("%.2f", haruka_mult) .. ")")
                end
                
                -- Recreate time events for remaining items
                local remaining_items = hidden_count + silhouette_count
                local rmult = corpse_rank[npc_id] or 1.0
                
                -- Determine effective max time (with Haruka's Skills bonus)
                local effective_max = time_max * rmult * haruka_mult
                if remaining_items <= 2 then
                    effective_max = math.min(effective_max, 3.0 * haruka_mult)
                elseif remaining_items <= 5 then
                    effective_max = math.min(effective_max, 7.0 * haruka_mult)
                end
                
                -- Track cumulative time for hidden items
                local cumulative_time = first_item_delay * haruka_mult
                
                for item_id, state in pairs(corpses[npc_id]) do
                    if state == "hidden" then
                        if placeholder_mode == 2 then
                            -- Two-stage: schedule silhouette then reveal (with Haruka's Skills bonus)
                            local appear_time = silhouette_appear_min + math.random() * (silhouette_appear_max - silhouette_appear_min)
                            appear_time = appear_time * haruka_mult
                            cumulative_time = cumulative_time + appear_time
                            
                            local silhouette_time = math.min(cumulative_time * rmult, effective_max - delay_between_max * haruka_mult * 0.5)
                            silhouette_time = math.max(silhouette_time, 0.1)
                            
                            local reveal_time = math.min(silhouette_time + get_random_delay() * haruka_mult, effective_max)
                            
                            CreateTimeEvent("item_silhouette", "silhouette_" .. npc_id .. "_" .. item_id,
                                            silhouette_time, reveal_silhouette, npc_id, item_id)
                            CreateTimeEvent("item_hiding", "item_hiding_" .. npc_id .. "_" .. item_id,
                                            reveal_time, reveal_item, npc_id, item_id)
                        else
                            -- Single-stage: use calc_search_time
                            local search_time = calc_search_time(remaining_items, npc_id, remaining_items)
                            CreateTimeEvent("item_hiding", "item_hiding_" .. npc_id .. "_" .. item_id,
                                            search_time, reveal_item, npc_id, item_id)
                        end
                    elseif state == "silhouette" then
                        -- Already silhouette, just schedule reveal with random delay (with Haruka's Skills bonus)
                        local reveal_time = math.min(get_random_delay() * haruka_mult, effective_max)
                        CreateTimeEvent("item_hiding", "item_hiding_" .. npc_id .. "_" .. item_id,
                                        reveal_time, reveal_item, npc_id, item_id)
                    end
                end
            end
        end
        
        cur_npc_id = npc_id
    end
    
    -- Dark silhouettes mode: show all items (visuals applied in Update)
    if placeholder_mode == 1 then
        return inv
    end
    
    -- Loading icon mode: filter "hidden" items, show "silhouette" and revealed
    -- Visuals applied in Update
    if placeholder_mode == 2 then
        local filtered = {}
        local idx = 1
        if id_list then
            for item_id, val in pairs(inv) do
                local state = corpses[npc_id] and corpses[npc_id][item_id]
                if state ~= "hidden" then
                    filtered[item_id] = val
                end
            end
        else
            for k, obj in pairs(inv) do
                if obj and type(obj.id) == "function" then
                    local item_id = obj:id()
                    local state = corpses[npc_id] and corpses[npc_id][item_id]
                    if state ~= "hidden" then
                        filtered[idx] = obj
                        idx = idx + 1
                    end
                end
            end
        end
        inv = filtered
        return inv
    end
    
    -- No placeholder mode: filter all hidden items
    if id_list then
        for item_id, _ in pairs(inv) do
            local state = corpses[npc_id] and corpses[npc_id][item_id]
            if state == "hidden" or state == "silhouette" then
                inv[item_id] = nil
            end
        end
    else
        local filtered = {}
        local idx = 1
        for k, obj in pairs(inv) do
            if obj and type(obj.id) == "function" then
                local item_id = obj:id()
                local state = corpses[npc_id] and corpses[npc_id][item_id]
                if state ~= "hidden" and state ~= "silhouette" then
                    filtered[idx] = obj
                    idx = idx + 1
                end
            end
        end
        inv = filtered
    end
    
    return inv
end

------------------------------------------------------------------------
-- FINDFREECELL OVERRIDE
------------------------------------------------------------------------
local baseFindFreeCell = utils_ui.UICellContainer.FindFreeCell

function utils_ui.UICellContainer:FindFreeCell(obj, sec)
    if self.ID ~= "npc_bag" then
        return baseFindFreeCell(self, obj, sec)
    end
    
    local item_id = obj and obj:id()
    if not item_id or not cur_npc_id then
        return baseFindFreeCell(self, obj, sec)
    end
    
    local pos = item_positions[cur_npc_id] and item_positions[cur_npc_id][item_id]
    if not pos then
        return baseFindFreeCell(self, obj, sec)
    end
    
    while #self.grid < pos.row + pos.h - 1 do
        self:Grow()
    end
    
    return self:TakeRoom(pos.row, pos.col, pos.w, pos.h)
end

------------------------------------------------------------------------
-- BLOCK INTERACTION WITH HIDDEN ITEMS
------------------------------------------------------------------------

-- Block highlight on hover
local base_UICellItem_Highlight = utils_ui.UICellItem.Highlight
function utils_ui.UICellItem:Highlight(state)
    if cur_npc_id and self.ID then
        local item_id = tonumber(self.ID)
        if item_id and is_item_hidden(cur_npc_id, item_id) then
            if self.hl then
                self.hl:Show(false)
            end
            return
        end
    end
    return base_UICellItem_Highlight(self, state)
end

-- Block item info tooltip display AND apply placeholder visuals
local base_UICellContainer_Update = utils_ui.UICellContainer.Update
function utils_ui.UICellContainer:Update(item_info, no_info, hide)
    -- Only intercept for npc_bag
    if self.ID == "npc_bag" and cur_npc_id then
        -- Apply placeholder visuals immediately to prevent flash
        if placeholder_mode > 0 and corpses[cur_npc_id] then
            local sil_r, sil_g, sil_b = get_silhouette_color()
            
            for i = 1, #self.cell do
                local ci = self.cell[i]
                if ci and ci.ico then
                    local item_id = ci.ID and tonumber(ci.ID)
                    if item_id then
                        local state = corpses[cur_npc_id][item_id]
                        if state == "hidden" or state == "silhouette" then
                            -- Apply silhouette color
                            local alpha = (state == "silhouette") and 220 or 255
                            ci.ico:SetTextureColor(GetARGB(alpha, sil_r, sil_g, sil_b))
                            
                            -- Create spinner for silhouette items (loading icon mode)
                            if placeholder_mode == 2 and state == "silhouette" then
                                create_spinner_for_cell(item_id, ci)
                            end
                        elseif state == false then
                            -- Revealed - ensure full color
                            ci.ico:SetTextureColor(GetARGB(255, 255, 255, 255))
                            remove_spinner(item_id)
                        end
                    end
                end
            end
        end
        
        -- Check if cursor is over a hidden item
        if self:IsCursorOverWindow() then
            for i = 1, #self.cell do
                local ci = self.cell[i]
                if ci and ci:IsCursorOverWindow() and ci:IsShown() then
                    local item_id = ci.ID and tonumber(ci.ID)
                    if item_id and is_item_hidden(cur_npc_id, item_id) then
                        -- Don't show item info for hidden items
                        if item_info then
                            item_info:Update()  -- Clear info
                        end
                        return false
                    end
                end
            end
        end
    end
    return base_UICellContainer_Update(self, item_info, no_info, hide)
end

-- Block mouse clicks on hidden items
local base_On_CC_Mouse1 = ui_inventory.UIInventory.On_CC_Mouse1
function ui_inventory.UIInventory:On_CC_Mouse1(bag, idx)
    if bag == "npc_bag" and cur_npc_id then
        local cc = self.CC and self.CC[bag]
        if cc then
            local ci = cc.cell and cc.cell[idx]
            if ci then
                local item_id = ci.ID and tonumber(ci.ID)
                if item_id and is_item_hidden(cur_npc_id, item_id) then
                    pr("Blocked click on hidden item %d", item_id)
                    return
                end
            end
        end
    end
    return base_On_CC_Mouse1(self, bag, idx)
end

-- Block double-click on hidden items
local base_On_CC_Mouse1_DB = ui_inventory.UIInventory.On_CC_Mouse1_DB
function ui_inventory.UIInventory:On_CC_Mouse1_DB(bag, idx)
    if bag == "npc_bag" and cur_npc_id then
        local cc = self.CC and self.CC[bag]
        if cc then
            local ci = cc.cell and cc.cell[idx]
            if ci then
                local item_id = ci.ID and tonumber(ci.ID)
                if item_id and is_item_hidden(cur_npc_id, item_id) then
                    pr("Blocked double-click on hidden item %d", item_id)
                    return
                end
            end
        end
    end
    return base_On_CC_Mouse1_DB(self, bag, idx)
end

-- Block right-click context menu on hidden items
local base_On_CC_Mouse2 = ui_inventory.UIInventory.On_CC_Mouse2
function ui_inventory.UIInventory:On_CC_Mouse2(bag, idx)
    if bag == "npc_bag" and cur_npc_id then
        local cc = self.CC and self.CC[bag]
        if cc then
            local ci = cc.cell and cc.cell[idx]
            if ci then
                local item_id = ci.ID and tonumber(ci.ID)
                if item_id and is_item_hidden(cur_npc_id, item_id) then
                    pr("Blocked right-click on hidden item %d", item_id)
                    return
                end
            end
        end
    end
    return base_On_CC_Mouse2(self, bag, idx)
end

-- Block drag & drop of hidden items
local base_On_CC_DragDrop = ui_inventory.UIInventory.On_CC_DragDrop
function ui_inventory.UIInventory:On_CC_DragDrop(bag_from, idx_from)
    if bag_from == "npc_bag" and cur_npc_id then
        local cc = self.CC and self.CC[bag_from]
        if cc then
            local ci = cc.cell and cc.cell[idx_from]
            if ci then
                local item_id = ci.ID and tonumber(ci.ID)
                if item_id and is_item_hidden(cur_npc_id, item_id) then
                    pr("Blocked drag of hidden item %d", item_id)
                    return
                end
            end
        end
    end
    return base_On_CC_DragDrop(self, bag_from, idx_from)
end

------------------------------------------------------------------------
-- HUD INDICATOR
------------------------------------------------------------------------
local current_hud_icon = nil
local current_indicator_style = nil
local current_indicator_x = nil
local current_indicator_y = nil
local current_indicator_scale = nil
local current_text_x = nil
local current_text_y = nil

function ui_inventory.UIInventory:InitIconX()
    -- Reuse cached XML parser (same file as spinners)
    local xml = get_spinner_xml()
    
    current_hud_icon = hud_icon
    current_indicator_style = hud_indicator_style
    current_indicator_x = hud_indicator_x
    current_indicator_y = hud_indicator_y
    current_indicator_scale = hud_indicator_scale
    current_text_x = hud_text_x
    current_text_y = hud_text_y
    
    if hud_icon == 1 then
        self.loot_icon_x = xml:InitTextWnd("looting_text", self)
        self.loot_icon_x:SetText(get_looting_text())
        -- Set position from MCM settings
        self.loot_icon_x:SetWndPos(vector2():set(hud_text_x, hud_text_y))
    elseif hud_icon == 2 then
        self.loot_icon_x = xml:InitStatic("loot_indicator_anim", self)
        -- Set texture based on selected style
        local texture_path = "ui\\loot_indicator\\" .. hud_indicator_style .. "\\indicator_01"
        self.loot_icon_x:InitTexture(texture_path)
        self.loot_icon_x:SetStretchTexture(true)
        -- Set position from MCM settings
        self.loot_icon_x:SetWndPos(vector2():set(hud_indicator_x, hud_indicator_y))
        -- Apply scale (base size is 140x21)
        local scale = hud_indicator_scale / 100
        local w = 140 * scale
        local h = 21 * scale
        self.loot_icon_x:SetWndSize(vector2():set(w, h))
    end
end

function ui_inventory.UIInventory:ReinitIconX()
    -- Destroy old indicator
    if self.loot_icon_x then
        self.loot_icon_x:Show(false)
        self.loot_icon_x = nil
    end
    -- Recreate with new settings
    self:InitIconX()
end

local baseUpdateInfo = ui_inventory.UIInventory.UpdateInfo
function ui_inventory.UIInventory:UpdateInfo(go)
    self:LootUpdateX()
    baseUpdateInfo(self, go)
end

local hud_tmr
local snd_tmr = 0
local dots = 0

-- Generate animated "Searching . . ." text (moved outside for performance)
local function dots_str()
    local str = get_looting_text()
    dots = dots < 5 and dots + 1 or 1
    for i = 1, dots do
        str = str .. " ."
    end
    return str
end

function ui_inventory.UIInventory:LootUpdateX()
    local tg = time_global()
    if (hud_tmr and tg < hud_tmr) then return end
    hud_tmr = tg + 500
    
    -- Check if settings changed and reinitialize if needed
    if self.loot_icon_x then
        local needs_reinit = current_hud_icon ~= hud_icon
        if hud_icon == 1 then
            needs_reinit = needs_reinit or current_text_x ~= hud_text_x
            needs_reinit = needs_reinit or current_text_y ~= hud_text_y
        elseif hud_icon == 2 then
            needs_reinit = needs_reinit or current_indicator_style ~= hud_indicator_style
            needs_reinit = needs_reinit or current_indicator_x ~= hud_indicator_x
            needs_reinit = needs_reinit or current_indicator_y ~= hud_indicator_y
            needs_reinit = needs_reinit or current_indicator_scale ~= hud_indicator_scale
        end
        if needs_reinit then
            self:ReinitIconX()
        end
    end
    
    if not self.loot_icon_x then
        self:InitIconX()
    end
    
    if not cur_npc_id then
        self.loot_icon_x:Show(false)
        return
    end
    
    if not hud_enable then
        self.loot_icon_x:Show(false)
        return
    end
    
    -- Count hidden items directly from cur_npc_id table (performance fix)
    local itms = 0
    local npc_corpse = corpses[cur_npc_id]
    if npc_corpse then
        for item_id, val in pairs(npc_corpse) do
            if val then
                itms = itms + 1
            end
        end
    end
    
    if itms <= 0 then
        self.loot_icon_x:Show(false)
        return
    end
    
    -- looting sound
    if sound_bg_enable and tg > snd_tmr then
        local snd_file = "looting\\looting_" .. math.random(1, 12)
        local snd = sound_object(snd_file)
        if snd then
            snd_tmr = tg + snd:length() * 0.5
            snd:play_at_pos(db.actor, VEC_ZERO, 0, sound_object.s2d)
            snd.volume = snd.volume * sound_bg_enable_vol
        end
    end
    
    self.loot_icon_x:Show(true)
    if hud_icon == 1 then
        self.loot_icon_x:SetText(dots_str())
    end
end

------------------------------------------------------------------------
-- CALLBACKS
------------------------------------------------------------------------
function GUI_on_show(name)
    if name ~= "UIInventory" then return end
    CreateTimeEvent("init_inv_ev", "init_inv_ac", 0, save_initial_inv)
end

function GUI_on_hide(name)
    if name ~= "UIInventory" then return end
    
    local inventory = ui_inventory.GUI
    if not inventory then return end
    if inventory.mode ~= "loot" then return end
    
    -- Cleanup spinners
    cleanup_all_spinners()
    
    -- Remove time events but DON'T change item states
    -- Items will remain in hidden/silhouette state until reopened
    for npc_id, t in pairs(corpses) do
        -- Clear resumed flag so search can be resumed next time
        resumed_search[npc_id] = nil
        
        for item_id, state in pairs(t) do
            if state == "hidden" or state == "silhouette" then
                RemoveTimeEvent("item_silhouette", "silhouette_" .. npc_id .. "_" .. item_id)
                RemoveTimeEvent("item_hiding", "item_hiding_" .. npc_id .. "_" .. item_id)
                -- DON'T set to nil - keep the hidden/silhouette state
            end
        end
    end
    
    cur_npc_id = nil
end

function server_entity_on_unregister(se_obj)
    local id = se_obj.id
    corpses[id] = nil
    initial_inv[id] = nil
    corpse_rank[id] = nil
    item_positions[id] = nil
    item_reveal_order[id] = nil
    resumed_search[id] = nil
end

function on_option_change()
    load_settings()
    -- Invalidate caches that depend on settings
    update_silhouette_color_cache()
end

------------------------------------------------------------------------
-- INIT
------------------------------------------------------------------------
------------------------------------------------------------------------
-- MAGAZINES REDUX COMPATIBILITY
------------------------------------------------------------------------
-- Suppress Magazines Redux sorting during active looting to prevent position conflicts
local function hook_magazines_redux()
    -- Always log this check regardless of debug mode
    printf("[LootTime] Checking for Magazines Redux: magazines=%s, inventory_refresh=%s", 
        tostring(magazines ~= nil), 
        tostring(magazines and magazines.inventory_refresh ~= nil))
    
    if not magazines then return end
    if not magazines.inventory_refresh then return end
    
    printf("[LootTime] Magazines Redux detected, hooking inventory_refresh (block_sort=%s)", tostring(block_mags_redux_sort))
    
    local base_mag_inventory_refresh = magazines.inventory_refresh
    
    function magazines.inventory_refresh(mode)
        -- If complete blocking is enabled, always force simple refresh
        if block_mags_redux_sort then
            pr("  Blocking Magazines Redux sort (MCM option enabled)")
            return base_mag_inventory_refresh(2)
        end
        
        -- Check if we're actively looting with unrevealed items
        if cur_npc_id and corpses[cur_npc_id] then
            local has_hidden = false
            for item_id, state in pairs(corpses[cur_npc_id]) do
                if state == "hidden" or state == "silhouette" then
                    has_hidden = true
                    break
                end
            end
            
            -- If still searching, force simple refresh (mode=2) instead of full sort
            if has_hidden then
                pr("  Suppressing Magazines Redux sort during active search")
                return base_mag_inventory_refresh(2)
            end
        end
        
        -- Otherwise let it sort normally
        return base_mag_inventory_refresh(mode)
    end
end

function on_game_start()
    load_settings()
    -- Initialize caches
    update_silhouette_color_cache()
    
    -- Hook Magazines Redux if installed
    hook_magazines_redux()
    
    RegisterScriptCallback("GUI_on_show", GUI_on_show)
    RegisterScriptCallback("GUI_on_hide", GUI_on_hide)
    RegisterScriptCallback("server_entity_on_unregister", server_entity_on_unregister)
    RegisterScriptCallback("on_option_change", on_option_change)
end
